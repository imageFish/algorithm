## 最长回文子串-leetcode 5
区分定义
- 子串：连续 $s_{i}s_{i+1}\cdots s_{j}, i \leq j$
- 子序列：非连续 $s_{a_0}s_{a_1} \cdots s_{a_n}, a_0 \leq a_1 \leq \cdots \leq a_n$
### Manache算法
1. 由于回文子串长度可能为奇数或者偶数，所以回文子串的中心可能是一个字符，也可能是两个字符。为了得到这种统一表示，向其中添加#(未出现过的字符)，收尾也添加。得到新串$B$，原串为$A$
$$
|B| = 2|A|+1\\
A_i = B_j \Rightarrow j =2i+1 
$$
2. $A, B$回文相同
   - 对于$A$中任意回文，在其首尾添加#，依然是回文；
   - 对于$B$中任意回文，其首尾必为#且长度为奇数，由于#在原串$A$中未出现过，所以#必和#相对应，即去除#之后，回文依然成立，此时已为$A$中子串。
   - 综上，$A$,$B$回文相同
3. 动态规划
   - 动机：充分利用已找到的回文信息提供给当前点
   - 状态：保存每一个点的回文臂长$p$，即去除本身的单方向延伸长度，$B$中回文长度必为奇数且大于等于3.
   - 在找到的回文中，记录能够达到的最右端的位置$tr$，以及其对应的中心点$t$。原因：能为当前点提供最多回文信息的就是以$t$为中心的回文。遍历从左开始。
   - 转移：当前位置$i$
     - $i \ge tr$, 说明无法利用之前的回文信息。需要一一查找, 此时$p_i=0$
     - $i < tr$, 说明之前找到的回文一部分可以作为当前点回文的一部分（其关于$t$的对称点$j=2t-i$的回文有一部分在$t$的回文外）或者全部（其关于$t$的对称点$j=2t-i$的回文全部被$t$的回文包括时），综合两种情况,$p_i=min(tr-i, \quad p_j)$
     - 在$p_i$的基础上扩展，第二种情况的第二种只需要扩展一次就退出了，所以时间复杂度以$tr$为标准，$O(log(n))$
     - 更新$tr$, $t$